Got it üëç Let‚Äôs go **deep** into **Day 15‚Äì16: RBAC & Policies**.
This is one of the most important Kubernetes concepts for **security, access control, and multi-team usage**.

I‚Äôll cover **concepts ‚Üí YAML ‚Üí hands-on ‚Üí best practices ‚Üí troubleshooting**.

---

# **Day 15‚Äì16: RBAC & Policies**

---

## **1. Why RBAC in Kubernetes?**

* By default, Kubernetes has a **powerful API**.
* If you give full access to everyone ‚Üí **security risk**.
* **RBAC (Role-Based Access Control)** ensures:

  * **Who (user/service account)** can do
  * **What (verbs like get, list, create, delete)** on
  * **Which resources (pods, deployments, secrets, etc.)**
  * In a **namespace** or **cluster-wide**

---

## **2. Key RBAC Objects**

| Object                 | Scope        | Purpose                                                                    |
| ---------------------- | ------------ | -------------------------------------------------------------------------- |
| **Role**               | Namespace    | Set of permissions within **one namespace**                                |
| **ClusterRole**        | Cluster-wide | Permissions across all namespaces or non-namespaced resources (nodes, PVs) |
| **RoleBinding**        | Namespace    | Assigns a Role to a user/group/SA in a namespace                           |
| **ClusterRoleBinding** | Cluster-wide | Assigns a ClusterRole to a user/group/SA across cluster                    |

---

## **3. Verbs in RBAC**

* `get` ‚Üí read a single resource
* `list` ‚Üí list multiple resources
* `watch` ‚Üí subscribe to changes
* `create` ‚Üí create new resources
* `update` ‚Üí modify existing resources
* `patch` ‚Üí partial update
* `delete` ‚Üí delete resources

üëâ Example: `get, list, watch` are usually **read-only**.
üëâ `create, update, delete` are **write** actions.

---

## **4. Example: Create Role & RoleBinding**

### **Role YAML (Namespace Scoped)**

```yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  namespace: dev
  name: pod-reader
rules:
- apiGroups: [""]
  resources: ["pods"]
  verbs: ["get", "list"]
```

üëâ This allows **only reading pods** inside the `dev` namespace.

---

### **RoleBinding YAML**

```yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: read-pods-binding
  namespace: dev
subjects:
- kind: User
  name: developer   # must match configured Kubernetes user
  apiGroup: rbac.authorization.k8s.io
roleRef:
  kind: Role
  name: pod-reader
  apiGroup: rbac.authorization.k8s.io
```

üëâ This **binds the Role** to user `developer`.

---

### **Commands (Shortcut)**

```bash
kubectl create role dev-role \
  --verb=get,list,create \
  --resource=pods \
  -n dev

kubectl create rolebinding dev-binding \
  --role=dev-role \
  --user=developer \
  -n dev
```

---

## **5. ClusterRole & ClusterRoleBinding**

### **ClusterRole Example**

```yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: cluster-admin-lite
rules:
- apiGroups: [""]
  resources: ["pods", "nodes"]
  verbs: ["get", "list"]
```

üëâ This allows **read-only access to pods and nodes** across the whole cluster.

---

### **ClusterRoleBinding Example**

```yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: cluster-read-binding
subjects:
- kind: User
  name: ops-team
  apiGroup: rbac.authorization.k8s.io
roleRef:
  kind: ClusterRole
  name: cluster-admin-lite
  apiGroup: rbac.authorization.k8s.io
```

---

## **6. Service Accounts with RBAC**

Often, applications running inside pods need to call the Kubernetes API.
They do this using **ServiceAccounts (SA)**.

### **ServiceAccount + Role Example**

```yaml
apiVersion: v1
kind: ServiceAccount
metadata:
  name: app-sa
  namespace: dev
---
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  namespace: dev
  name: app-role
rules:
- apiGroups: [""]
  resources: ["configmaps"]
  verbs: ["get", "list"]
---
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: app-binding
  namespace: dev
subjects:
- kind: ServiceAccount
  name: app-sa
  namespace: dev
roleRef:
  kind: Role
  name: app-role
  apiGroup: rbac.authorization.k8s.io
```

üëâ Now pods running with `app-sa` can read configmaps.

---

## **7. Testing RBAC**

1. Switch to a user context:

   ```bash
   kubectl config use-context developer@cluster
   ```
2. Try to list pods:

   ```bash
   kubectl get pods -n dev
   ```
3. Try to delete pods (should fail if not allowed):

   ```bash
   kubectl delete pod <pod-name> -n dev
   ```
4. Check authorization directly:

   ```bash
   kubectl auth can-i delete pods -n dev --as developer
   ```

---

## **8. RBAC Best Practices**

‚úÖ Follow **least privilege** principle ‚Üí give minimum required verbs.
‚úÖ Use **namespaced Roles** for team isolation.
‚úÖ Use **ClusterRoles** only for cluster-wide roles (admins, ops).
‚úÖ Audit with:

```bash
kubectl get roles,rolebindings -A
kubectl get clusterroles,clusterrolebindings
```

‚úÖ Rotate **ServiceAccount tokens** regularly.
‚úÖ Use **OPA Gatekeeper** or **Kyverno** for enforcing policies (advanced).

---

## **9. Troubleshooting RBAC**

* **User denied access**:

  ```bash
  Error from server (Forbidden): pods is forbidden: User "developer" cannot list resource "pods"
  ```

  üëâ Check Role/RoleBinding.

* **ClusterRole not working in namespace** ‚Üí Need **ClusterRoleBinding**, not RoleBinding.

* Verify with:

  ```bash
  kubectl auth can-i <verb> <resource> -n <namespace> --as <user>
  ```

---

## **10. Key Takeaways**

* **Role & RoleBinding** ‚Üí namespace scoped.
* **ClusterRole & ClusterRoleBinding** ‚Üí cluster scoped.
* Use **ServiceAccounts** for pods.
* Always enforce **least privilege**.

---


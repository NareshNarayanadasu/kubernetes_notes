Perfect! Let’s cover **Day 5–6: StatefulSets & DaemonSets** in **complete depth**, including **every small concept, difference with Deployments, workflow, YAML examples, and best practices**.

---

# **Day 5–6: StatefulSets & DaemonSets – In-Depth Guide**

Kubernetes has **different types of workload controllers** depending on the nature of the application. While **Deployments** are for stateless apps, **StatefulSets and DaemonSets** are used for stateful and node-level apps.

---

## **1. StatefulSets**

### **1.1 What is a StatefulSet?**

* Manages **stateful applications** where **each pod requires a stable identity and storage**.
* Examples: Databases (MySQL, PostgreSQL, MongoDB), Kafka, Zookeeper.
* Provides:

  * **Stable, unique network IDs** (pod names remain constant)
  * **Stable storage** via PersistentVolumeClaim
  * **Ordered deployment, scaling, and termination**

### **1.2 Key Features of StatefulSets**

| Feature                          | Description                                                                      |
| -------------------------------- | -------------------------------------------------------------------------------- |
| **Stable Pod Name**              | Pods get predictable names: `<statefulset-name>-0`, `<statefulset-name>-1`, etc. |
| **Stable Network Identity**      | Pod retains hostname and DNS identity even after rescheduling.                   |
| **Stable Storage**               | Each pod gets a dedicated PersistentVolume (PVC) that is preserved.              |
| **Ordered Deployment & Scaling** | Pods are created/deleted sequentially.                                           |
| **Ordered Rolling Updates**      | Update pods one by one, respecting order.                                        |

---

### **1.3 StatefulSet vs Deployment**

| Aspect            | Deployment          | StatefulSet                        |
| ----------------- | ------------------- | ---------------------------------- |
| **Pod Identity**  | Ephemeral           | Stable, unique                     |
| **Network**       | Dynamic IP          | Stable DNS                         |
| **Storage**       | Shared or ephemeral | Dedicated PersistentVolume per pod |
| **Scaling Order** | Parallel            | Sequential (0 → N-1)               |
| **Use Case**      | Stateless apps      | Stateful apps (DBs, queues)        |

---

### **1.4 Headless Service**

* Required to **allow pods to have stable DNS names**.
* No load-balancing; DNS resolves each pod individually.

```yaml
apiVersion: v1
kind: Service
metadata:
  name: mysql
spec:
  clusterIP: None
  selector:
    app: mysql
  ports:
  - port: 3306
```

---

### **1.5 StatefulSet YAML Example**

```yaml
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: mysql
spec:
  serviceName: "mysql" # Headless service
  replicas: 3
  selector:
    matchLabels:
      app: mysql
  template:
    metadata:
      labels:
        app: mysql
    spec:
      containers:
      - name: mysql
        image: mysql:8
        env:
        - name: MYSQL_ROOT_PASSWORD
          value: "rootpassword"
        ports:
        - containerPort: 3306
        volumeMounts:
        - name: mysql-data
          mountPath: /var/lib/mysql
  volumeClaimTemplates:
  - metadata:
      name: mysql-data
    spec:
      accessModes: ["ReadWriteOnce"]
      resources:
        requests:
          storage: 5Gi
```

**Commands:**

```bash
kubectl apply -f mysql-service.yaml
kubectl apply -f mysql-statefulset.yaml
kubectl get pods -l app=mysql
kubectl describe statefulset mysql
```

**Hands-On Tasks:**

1. Scale StatefulSet and observe pod order:

```bash
kubectl scale statefulset mysql --replicas=5
```

2. Delete a pod and see persistent volume retention:

```bash
kubectl delete pod mysql-2
kubectl get pvc
```

---

## **2. DaemonSets**

### **2.1 What is a DaemonSet?**

* Ensures that **a copy of a pod runs on all nodes**, or specific nodes based on labels.
* Typically used for **node-level services**:

  * Monitoring agents (Prometheus node exporter)
  * Logging agents (Fluentd, Filebeat)
  * Network plugins (CNI)
  * Security/antivirus agents

---

### **2.2 Key Features**

| Feature                  | Description                                     |
| ------------------------ | ----------------------------------------------- |
| **One pod per node**     | Guarantees coverage across all nodes.           |
| **Selective Nodes**      | Can target nodes with nodeSelector or affinity. |
| **Automatic Deployment** | New nodes automatically get DaemonSet pods.     |
| **No Scaling**           | Scaling is automatic based on nodes.            |

---

### **2.3 DaemonSet YAML Example**

```yaml
apiVersion: apps/v1
kind: DaemonSet
metadata:
  name: fluentd
  namespace: kube-system
spec:
  selector:
    matchLabels:
      name: fluentd
  template:
    metadata:
      labels:
        name: fluentd
    spec:
      containers:
      - name: fluentd
        image: fluent/fluentd:v1.14
        resources:
          limits:
            memory: 200Mi
            cpu: 200m
        volumeMounts:
        - name: varlog
          mountPath: /var/log
      volumes:
      - name: varlog
        hostPath:
          path: /var/log
```

**Commands:**

```bash
kubectl apply -f daemonset.yaml
kubectl get daemonset -n kube-system
kubectl describe daemonset fluentd -n kube-system
```

---

### **2.4 DaemonSet vs Deployment**

| Aspect            | Deployment        | DaemonSet                                   |
| ----------------- | ----------------- | ------------------------------------------- |
| **Pod Placement** | Scheduler decides | 1 pod per node                              |
| **Scaling**       | Manual / HPA      | Automatic based on nodes                    |
| **Use Case**      | App workloads     | Node-level agents                           |
| **Updates**       | Rolling update    | Update strategy (RollingUpdate or OnDelete) |

---

### **3. StatefulSet & DaemonSet Use Cases**

**StatefulSet:**

* Databases (MySQL, Postgres)
* Distributed systems (Kafka, Zookeeper)
* Applications requiring **stable network ID & persistent storage**

**DaemonSet:**

* Log collection agents (Fluentd, Filebeat)
* Node monitoring (Prometheus Node Exporter)
* Network & security tools
* Node-level proxies or service mesh sidecars

---

### **4. Hands-On Lab Summary**

1. **Deploy StatefulSet with Headless Service:**

```bash
kubectl apply -f mysql-service.yaml
kubectl apply -f mysql-statefulset.yaml
kubectl get pods -l app=mysql
kubectl describe statefulset mysql
```

2. **Scale StatefulSet and check pod order:**

```bash
kubectl scale statefulset mysql --replicas=5
kubectl get pods -l app=mysql
```

3. **Delete a pod and observe PVC retention:**

```bash
kubectl delete pod mysql-2
kubectl get pvc
```

4. **Deploy DaemonSet for node-level agent:**

```bash
kubectl apply -f daemonset.yaml
kubectl get daemonset -n kube-system
kubectl describe daemonset fluentd -n kube-system
```

5. **Add a new node and confirm DaemonSet pod creation**:

```bash
# On cluster with multiple nodes
kubectl get pods -o wide -n kube-system
```

---

### **5. Key Takeaways**

* **Deployments** → stateless workloads, scalable, rolling updates.
* **StatefulSets** → stateful workloads, stable pod identity, persistent storage, ordered scaling.
* **DaemonSets** → node-level pods, run on all nodes automatically.
* **Headless service** is mandatory for StatefulSets to provide stable DNS.
* **PVC per pod** ensures data survives pod rescheduling.

---



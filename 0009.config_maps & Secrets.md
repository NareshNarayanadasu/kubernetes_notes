Great üëç Let‚Äôs go deep into **Day 17‚Äì18: Secrets & ConfigMaps**.
This is **application configuration management** in Kubernetes ‚Äî one of the most used features when deploying real-world apps.

I‚Äôll break it down into **concepts ‚Üí YAML ‚Üí hands-on ‚Üí security ‚Üí best practices ‚Üí troubleshooting**.

---

# **Day 17‚Äì18: Secrets & ConfigMaps**

---

## **1. Why ConfigMaps & Secrets?**

Applications need:

* **ConfigMaps** ‚Üí Store **non-sensitive configuration** (like URLs, feature flags, app properties).
* **Secrets** ‚Üí Store **sensitive information** (like passwords, API keys, TLS certs).

üëâ Both let you **externalize configuration** from code & images ‚Üí more flexibility, security, and separation of concerns.

---

## **2. ConfigMaps**

### **2.1 What is ConfigMap?**

* Key-value pairs of **non-sensitive configuration**.
* Can be consumed by pods as:

  * Environment variables
  * Mounted files
  * Command-line arguments

---

### **2.2 Create ConfigMap**

#### From literal values:

```bash
kubectl create configmap app-config --from-literal=APP_MODE=production --from-literal=APP_PORT=8080
```

#### From a file:

```bash
kubectl create configmap app-config --from-file=config.yaml
```

#### From a directory:

```bash
kubectl create configmap app-config --from-file=./config-dir/
```

---

### **2.3 ConfigMap YAML Example**

```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: app-config
data:
  APP_MODE: "production"
  APP_PORT: "8080"
  config.yaml: |
    db:
      host: mysql
      port: 3306
```

---

### **2.4 Using ConfigMap in Pod**

#### As environment variables:

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: app-pod
spec:
  containers:
  - name: myapp
    image: busybox
    command: ["sh", "-c", "echo APP_MODE=$APP_MODE; sleep 3600"]
    envFrom:
    - configMapRef:
        name: app-config
```

#### As mounted file:

```yaml
volumeMounts:
- name: config-volume
  mountPath: /etc/config
volumes:
- name: config-volume
  configMap:
    name: app-config
```

üëâ Then inside pod: `/etc/config/config.yaml`

---

## **3. Secrets**

### **3.1 What is a Secret?**

* Similar to ConfigMap but for **sensitive data**.
* Stored **Base64-encoded** (not fully encrypted by default).
* Use encryption at rest (KMS, etcd encryption) + RBAC restrictions.

---

### **3.2 Create Secret**

#### From literal:

```bash
kubectl create secret generic db-secret --from-literal=username=admin --from-literal=password=12345
```

#### From file:

```bash
kubectl create secret generic tls-secret --from-file=cert.crt --from-file=cert.key
```

---

### **3.3 Secret YAML Example**

```yaml
apiVersion: v1
kind: Secret
metadata:
  name: db-secret
type: Opaque
data:
  username: YWRtaW4=   # base64 encoded 'admin'
  password: MTIzNDU=   # base64 encoded '12345'
```

üëâ Encode with:

```bash
echo -n 'admin' | base64
```

---

### **3.4 Using Secret in Pod**

#### As environment variables:

```yaml
env:
- name: DB_USER
  valueFrom:
    secretKeyRef:
      name: db-secret
      key: username
- name: DB_PASS
  valueFrom:
    secretKeyRef:
      name: db-secret
      key: password
```

#### As mounted file:

```yaml
volumeMounts:
- name: secret-volume
  mountPath: /etc/secrets
volumes:
- name: secret-volume
  secret:
    secretName: db-secret
```

üëâ Inside pod: `/etc/secrets/username`, `/etc/secrets/password`

---

## **4. Encrypting Secrets at Rest**

By default, secrets are just base64 ‚Üí visible if someone gets access to etcd.

### **Enable Encryption at Rest**

Create `EncryptionConfiguration` file for API server:

```yaml
apiVersion: apiserver.config.k8s.io/v1
kind: EncryptionConfiguration
resources:
- resources:
  - secrets
  providers:
  - kms:
      name: myKMS
      endpoint: unix:///tmp/socketfile.sock
      cachesize: 1000
      timeout: 3s
  - identity: {}
```

Then start `kube-apiserver` with:

```bash
--encryption-provider-config=/etc/kubernetes/encryption-config.yaml
```

üëâ Now secrets stored in etcd are **encrypted**.

---

## **5. Hands-On Lab**

### Step 1: Create Secret & ConfigMap

```bash
kubectl create secret generic db-secret --from-literal=password=12345
kubectl create configmap app-config --from-literal=APP_MODE=production
```

### Step 2: Pod using both

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: demo-pod
spec:
  containers:
  - name: busybox
    image: busybox
    command: ["sh", "-c", "echo APP_MODE=$APP_MODE && echo DB_PASS=$DB_PASS && sleep 3600"]
    env:
    - name: APP_MODE
      valueFrom:
        configMapKeyRef:
          name: app-config
          key: APP_MODE
    - name: DB_PASS
      valueFrom:
        secretKeyRef:
          name: db-secret
          key: password
```

```bash
kubectl exec -it demo-pod -- sh
echo $APP_MODE
echo $DB_PASS
```

---

## **6. Best Practices**

‚úÖ Use **ConfigMaps for non-sensitive**, Secrets for sensitive data.
‚úÖ Always **enable encryption at rest** for secrets.
‚úÖ Apply **RBAC restrictions** ‚Üí not everyone should read secrets.
‚úÖ Rotate secrets regularly.
‚úÖ Mount as files for apps that expect config files.
‚úÖ Avoid checking secrets into Git (use SealedSecrets, ExternalSecrets, Vault).

---

## **7. Troubleshooting**

* **Pod not getting env var?**

  * Check if key exists in Secret/ConfigMap.
  * Check spelling in YAML.

* **Secret shown in plain text?**

  * Base64 ‚â† encryption ‚Üí enable encryption at rest.

* **Secret not mounted?**

  ```bash
  kubectl describe pod demo-pod
  ```

  üëâ Look for `MountVolume.SetUp failed` ‚Üí usually missing secret.

---

## **8. Key Takeaways**

* **ConfigMaps** = non-sensitive config.
* **Secrets** = sensitive config (with encryption & RBAC).
* Both can be injected as **env vars** or **volumes**.
* Always secure secrets with **RBAC + encryption**.

---


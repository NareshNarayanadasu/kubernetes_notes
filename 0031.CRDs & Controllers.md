Perfect! Here’s the **complete in-depth text-only guide for Day 57–58: CRDs & Controllers**, fully detailed so you can study and follow without missing anything.

---

# **Day 57–58: Extending Kubernetes with CRDs & Controllers**

---

## **1. Lab Objective**

* Extend Kubernetes using **Custom Resource Definitions (CRDs)**.
* Create **Custom Resources (CRs)**.
* Write a **controller** to automate CR behavior.
* Learn **advanced features** like status updates, finalizers, validation, and versioning.

---

## **2. Why CRDs Are Important**

* Kubernetes has **built-in resources**: Pods, Deployments, Services.
* Sometimes you need **custom objects** beyond standard resources.
* **CRDs allow you to define new resource types** in Kubernetes.

**Use cases:**

* `Database` resource that provisions a database automatically.
* `BackupJob` resource to automate backups.
* `AppConfig` resource for managing deployment policies.

---

## **3. CRD Concepts**

| Concept             | Description                                                     |
| ------------------- | --------------------------------------------------------------- |
| CRD                 | Defines a new resource type in Kubernetes                       |
| CR                  | Instance of the CRD (real object)                               |
| Controller/Operator | Watches CR events and performs automated actions                |
| API Group & Version | CRDs belong to an API group and version, e.g., `example.com/v1` |

**Example CRD anatomy:**

```yaml
apiVersion: apiextensions.k8s.io/v1
kind: CustomResourceDefinition
metadata:
  name: databases.example.com
spec:
  group: example.com
  versions:
    - name: v1
      served: true
      storage: true
      schema:
        openAPIV3Schema:
          type: object
          properties:
            spec:
              type: object
              properties:
                engine:
                  type: string
                version:
                  type: string
  scope: Namespaced
  names:
    plural: databases
    singular: database
    kind: Database
    shortNames:
    - db
```

---

## **4. Hands-on: Creating a CRD**

1. Apply the CRD:

```bash
kubectl apply -f database-crd.yaml
```

2. Verify:

```bash
kubectl get crd
kubectl get databases
```

---

## **5. Creating a Custom Resource (CR)**

**Example CR (my-database.yaml):**

```yaml
apiVersion: example.com/v1
kind: Database
metadata:
  name: my-database
  namespace: default
spec:
  engine: postgres
  version: "14"
```

**Apply CR:**

```bash
kubectl apply -f my-database.yaml
kubectl get databases
kubectl describe database my-database
```

---

## **6. Writing a Controller**

### **6.1 Controller Concepts**

* Controllers watch **CR events**: `ADD`, `UPDATE`, `DELETE`.
* Automate creation/updating/deletion of resources based on CR spec.
* Can be written in **Go, Python, or Node.js**.

**Responsibilities:**

1. Detect new CRs.
2. Create/update resources based on CR.
3. Handle deletion gracefully.
4. Update CR `.status` to reflect current state.

---

### **6.2 Example Controller in Python (Kopf)**

**Install Kopf:**

```bash
pip install kopf kubernetes
```

**controller.py**

```python
import kopf
from kubernetes import client, config

config.load_kube_config()

@kopf.on.create('example.com', 'v1', 'databases')
def create_fn(spec, name, namespace, **kwargs):
    engine = spec.get('engine')
    version = spec.get('version')
    print(f"Creating database {name} with engine {engine} v{version}")
    
    api = client.CoreV1Api()
    cm = client.V1ConfigMap(
        metadata=client.V1ObjectMeta(name=name, namespace=namespace),
        data={"engine": engine, "version": version}
    )
    api.create_namespaced_config_map(namespace, cm)

@kopf.on.update('example.com', 'v1', 'databases')
def update_fn(spec, status, patch, **kwargs):
    patch.status['state'] = 'Configured'
```

**Run the controller:**

```bash
kopf run controller.py
```

---

## **7. Verify Controller Behavior**

* Apply CR:

```bash
kubectl apply -f my-database.yaml
```

* Check generated resources:

```bash
kubectl get configmap -n default
kubectl describe configmap my-database -n default
```

* Update CR and see status update:

```bash
kubectl edit database my-database
kubectl get database my-database -o yaml
```

---

## **8. Advanced CRD & Controller Features**

| Feature    | Usage                                                      |
| ---------- | ---------------------------------------------------------- |
| Status     | Controllers update `.status` to show state (e.g., `Ready`) |
| Finalizers | Ensure cleanup before deletion of CR                       |
| Validation | OpenAPI v3 schema in CRD ensures correct field types       |
| Versioning | Support multiple versions (`v1`, `v2`) for smooth upgrades |

**Example status update in controller:**

```python
patch.status['state'] = 'Ready'
```

---

## **9. Best Practices**

1. Validate CRD schema to prevent invalid CRs.
2. Use `.status` for CR state reporting.
3. Implement finalizers for proper cleanup.
4. Separate reconciliation logic in the controller.
5. Test CRDs/controllers on **dev cluster** first.
6. Maintain version compatibility when updating CRDs.

---

## **10. Troubleshooting**

| Issue                   | Solution                                                |
| ----------------------- | ------------------------------------------------------- |
| CRD not recognized      | Check `kubectl get crd`                                 |
| Controller not reacting | Ensure Kopf is running with correct kubeconfig          |
| Status not updating     | Use `patch.status` correctly and check RBAC permissions |
| Validation fails        | Ensure CRD OpenAPI schema matches CR fields             |

---

## **11. Lab Summary**

* Extended Kubernetes with **Custom Resource Definitions**.
* Created a **Custom Resource** (`Database`).
* Wrote a **controller** to automate CR management.
* Learned **advanced CRD features**: status, finalizers, validation, versioning.
* Gained hands-on ability to **build operators** for complex workloads.

---



Perfect! Here’s a **master, text-only Advanced Kubernetes Labs guide** combining **Day 57–62**, covering **CRDs, Controllers, Operators, DR, and Webhooks** in one complete document. Every topic is covered in detail for in-depth study and hands-on practice.

---

# **Advanced Kubernetes Labs: Days 57–62**

---

## **Day 57–58: CRDs & Controllers**

### **Objective**

* Extend Kubernetes with **Custom Resource Definitions (CRDs)**.
* Create **Custom Resources (CRs)**.
* Write a **controller/operator** to manage CRs automatically.
* Learn **status, finalizers, validation, and versioning**.

### **Key Concepts**

* **CRD:** Defines new resource type.
* **CR:** Instance of CRD.
* **Controller/Operator:** Watches CR events and reconciles state.
* **API Group & Version:** Organizes CRDs, e.g., `example.com/v1`.

### **Hands-on**

1. Create a CRD (`database-crd.yaml`):

```yaml
apiVersion: apiextensions.k8s.io/v1
kind: CustomResourceDefinition
metadata:
  name: databases.example.com
spec:
  group: example.com
  versions:
    - name: v1
      served: true
      storage: true
      schema:
        openAPIV3Schema:
          type: object
          properties:
            spec:
              type: object
              properties:
                engine:
                  type: string
                version:
                  type: string
  scope: Namespaced
  names:
    plural: databases
    singular: database
    kind: Database
    shortNames:
    - db
```

```bash
kubectl apply -f database-crd.yaml
kubectl get crd
```

2. Create a Custom Resource (`my-database.yaml`):

```yaml
apiVersion: example.com/v1
kind: Database
metadata:
  name: my-database
spec:
  engine: postgres
  version: "14"
```

```bash
kubectl apply -f my-database.yaml
kubectl get databases
kubectl describe database my-database
```

3. Write Python controller using **Kopf**:

```python
import kopf
from kubernetes import client, config

config.load_kube_config()

@kopf.on.create('example.com', 'v1', 'databases')
def create_fn(spec, name, namespace, **kwargs):
    engine = spec.get('engine')
    version = spec.get('version')
    api = client.CoreV1Api()
    cm = client.V1ConfigMap(
        metadata=client.V1ObjectMeta(name=name, namespace=namespace),
        data={"engine": engine, "version": version}
    )
    api.create_namespaced_config_map(namespace, cm)

@kopf.on.update('example.com', 'v1', 'databases')
def update_fn(spec, status, patch, **kwargs):
    patch.status['state'] = 'Configured'
```

```bash
kopf run controller.py
```

### **Advanced Features**

* Status updates for CRs.
* Finalizers to cleanup resources on deletion.
* Validation via OpenAPI v3 schema.
* Versioning for backward compatibility.

---

## **Day 59–60: Operators**

### **Objective**

* Understand **Operators**: controllers + CRDs + domain knowledge.
* Automate operational tasks (DB backup, scaling, upgrades).

### **Hands-on**

1. Install **etcd operator**:

```bash
kubectl create namespace etcd-operator
kubectl apply -f https://github.com/etcd-io/etcd-operator/releases/download/v0.9.4/etcd-operator.yaml
kubectl get pods -n etcd-operator
```

2. Deploy an Etcd cluster using operator:

```yaml
apiVersion: etcd.database.coreos.com/v1beta2
kind: EtcdCluster
metadata:
  name: example-etcd
  namespace: default
spec:
  size: 3
  version: "3.5.0"
  backup:
    backupStore:
      s3:
        bucket: "my-etcd-backups"
        prefix: "etcd-backup"
        region: "us-east-1"
```

```bash
kubectl apply -f etcd-cluster.yaml
kubectl get etcdclusters
kubectl get pods
kubectl logs -f <etcd-operator-pod> -n etcd-operator
```

3. Backup automation:

* Defined in CRD under `backup`.
* Operator creates snapshots to S3 automatically.

### **Best Practices**

* High availability for production operators.
* Define backup policies.
* Monitor operator logs.
* Use least-privilege RBAC.

---

## **Day 56: Disaster Recovery (DR) Lab Recap**

### **Objective**

* Practice **backup and restore** with Velero.
* Simulate **node failures** and restore workloads.

### **Hands-on**

1. Install Velero and configure storage:

```bash
velero install --provider aws --bucket <bucket> --secret-file ./credentials-velero --use-volume-snapshots=false --backup-location-config region=<region>
kubectl get pods -n velero
```

2. Deploy test app:

```bash
kubectl create ns dr-test
kubectl create deployment nginx --image=nginx -n dr-test
kubectl expose deployment nginx --port=80 -n dr-test
```

3. Backup workloads:

```bash
velero backup create dr-test-backup --include-namespaces dr-test
velero backup get
```

4. Simulate node failure:

```bash
kubectl cordon <node-name>
kubectl drain <node-name> --ignore-daemonsets --delete-emptydir-data
```

5. Restore workloads:

```bash
velero restore create --from-backup dr-test-backup
kubectl get pods -n dr-test
```

---

## **Day 61–62: API Aggregation & Webhooks**

### **Objective**

* Learn **API aggregation layer**.
* Study **admission controllers**.
* Implement **validating webhooks** for custom policies.

### **Admission Controller Types**

* **ValidatingWebhookConfiguration** → Approve/reject resources.
* **MutatingWebhookConfiguration** → Modify resources before storage.

### **Hands-on**

1. Create webhook server (Python Flask):

```python
from flask import Flask, request, jsonify
app = Flask(__name__)

@app.route('/validate', methods=['POST'])
def validate():
    request_info = request.get_json()
    labels = request_info['request']['object'].get('metadata', {}).get('labels', {})
    if 'team' not in labels:
        return jsonify({
            "response": {"allowed": False, "status": {"message": "Namespace must have a 'team' label"}}
        })
    return jsonify({"response": {"allowed": True}})

if __name__ == '__main__':
    app.run(host='0.0.0.0', port=443, ssl_context=('tls.crt','tls.key'))
```

2. Expose webhook via Service and Deployment.

3. Configure `ValidatingWebhookConfiguration`:

```yaml
apiVersion: admissionregistration.k8s.io/v1
kind: ValidatingWebhookConfiguration
metadata:
  name: namespace-label-validator
webhooks:
  - name: namespace-validator.example.com
    clientConfig:
      service:
        name: validating-webhook
        namespace: default
        path: "/validate"
      caBundle: <base64-cert>
    rules:
      - operations: ["CREATE", "UPDATE"]
        apiGroups: [""]
        apiVersions: ["v1"]
        resources: ["namespaces"]
    admissionReviewVersions: ["v1"]
    sideEffects: None
```

4. Test webhook:

```bash
kubectl create ns test-ns          # Rejected
kubectl create ns test-ns --labels team=dev  # Allowed
```

---

## **Master Lab Summary**

* **CRDs & Controllers:** Extend Kubernetes API, automate CRs.
* **Operators:** Automate operational tasks for complex apps.
* **Disaster Recovery:** Backup/restore workloads using Velero.
* **API Aggregation & Webhooks:** Enforce policies, validate resources, and extend API behavior.

✅ **Outcome:**

* You can **extend Kubernetes** with custom APIs, operators, and policies.
* Able to **automate application management** and ensure **DR readiness**.
* Hands-on practice with **CRDs, controllers, operators, backups, and webhooks**.

-
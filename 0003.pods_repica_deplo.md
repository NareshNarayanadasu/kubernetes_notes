Perfect! I understand now — you want **every concept in Kubernetes fully explained, no skipping**, with **theory, internal workflow, YAML examples, commands, best practices, and use cases**. We’ll go **extremely deep**, like a masterclass for someone with 5 years experience.

Let’s start with **Day 3–4: Pods, ReplicaSets, and Deployments**, and I’ll cover **every small topic, including side concepts**.

---

# **Day 3–4: Pods, ReplicaSets, and Deployments – Full In-Depth Guide**

Kubernetes workloads are structured hierarchically:

```
Deployment → ReplicaSet → Pod → Container
```

We’ll go step by step.

---

## **1. Pods (The Core Unit of Workloads)**

### **1.1 What is a Pod?**

* Smallest deployable unit in Kubernetes.
* Can contain **one or more tightly coupled containers**.
* All containers in a pod share:

  * **Network namespace** (IP address, port space)
  * **Volumes** (shared storage)
  * **IPC and PID namespace** (optional)
* Pods are **ephemeral**:

  * If a pod dies, a new pod may be created (with a new IP).
* Pods are **not meant to be directly scaled**; use **ReplicaSets/Deployments**.

---

### **1.2 Pod Lifecycle Phases**

1. **Pending:** Pod is accepted by API server but not scheduled yet.
2. **Running:** Pod assigned to a node; containers are running.
3. **Succeeded:** All containers have completed successfully (for Jobs).
4. **Failed:** Containers terminated with failure.
5. **Unknown:** Node not reachable; pod status cannot be confirmed.

---

### **1.3 Pod States & Conditions**

* **Conditions** are detailed statuses of pod:

  * `PodScheduled` – assigned to a node
  * `Ready` – ready to serve requests
  * `Initialized` – all init containers completed
  * `ContainersReady` – all app containers ready
* **Check pod conditions:**

```bash
kubectl get pod <pod-name> -o jsonpath='{.status.conditions}'
```

---

### **1.4 Pod Types**

* **Single-container pod:** Most common, e.g., nginx.
* **Multi-container pod:** Containers work together (sidecar pattern):

  * Example: Logging sidecar + app container.
* **Init Containers:** Run **before main containers** to prepare environment.

**YAML Example – Init Container:**

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: init-demo
spec:
  initContainers:
  - name: init-myservice
    image: busybox
    command: ['sh', '-c', 'echo Init container running; sleep 5']
  containers:
  - name: app
    image: nginx
```

---

### **1.5 Pod Networking**

* Each pod gets its **own IP**.
* Pods can communicate directly using pod IP (in cluster).
* Kubernetes **DNS service** resolves pod names.
* **Container ports vs Pod ports:**

  * Containers expose ports internally; pod IP is used for network access.

**Hands-On:**

```bash
kubectl run test-pod --image=nginx
kubectl get pods -o wide
kubectl exec -it test-pod -- curl localhost:80
```

---

## **2. ReplicaSets**

### **2.1 What is a ReplicaSet?**

* Ensures **desired number of pod replicas** are running.
* **Self-healing:** If a pod crashes, ReplicaSet creates a replacement.
* Managed by **Deployments**; usually not directly used in production.

### **2.2 Key Features**

* Matches pods using **labels**.
* Can scale pods easily.
* Tracks pod lifecycle and ensures consistency.

**YAML Example – ReplicaSet:**

```yaml
apiVersion: apps/v1
kind: ReplicaSet
metadata:
  name: nginx-rs
spec:
  replicas: 3
  selector:
    matchLabels:
      app: nginx
  template:
    metadata:
      labels:
        app: nginx
    spec:
      containers:
      - name: nginx
        image: nginx:latest
```

**Commands:**

```bash
kubectl apply -f replicaset.yaml
kubectl get rs
kubectl get pods -l app=nginx
kubectl describe rs nginx-rs
```

**Important Notes:**

* **Selector must match template labels**, otherwise ReplicaSet will not manage pods.
* Pods created manually **not matching labels** are ignored.
* Scaling:

```bash
kubectl scale rs nginx-rs --replicas=5
```

---

## **3. Deployments**

### **3.1 What is a Deployment?**

* High-level **controller that manages ReplicaSets**.
* Provides:

  * Rolling updates
  * Rollbacks
  * Scaling
  * Declarative desired state management

---

### **3.2 Deployment Features**

* **Rolling Updates:** Update pods gradually to minimize downtime.
* **Rollback:** Revert to a previous revision if new pods fail.
* **Revision history:** Tracks deployment versions.
* **Auto scaling:** Works with HPA for CPU/memory-based scaling.

**Command Examples:**

```bash
kubectl create deployment nginx --image=nginx
kubectl scale deployment nginx --replicas=3
kubectl rollout history deployment nginx
kubectl rollout undo deployment nginx
kubectl set image deployment/nginx nginx=nginx:1.25
kubectl rollout status deployment/nginx
```

---

### **3.3 Deployment YAML Example**

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: nginx-deployment
spec:
  replicas: 3
  selector:
    matchLabels:
      app: nginx
  template:
    metadata:
      labels:
        app: nginx
    spec:
      containers:
      - name: nginx
        image: nginx:1.24
        ports:
        - containerPort: 80
  strategy:
    type: RollingUpdate
    rollingUpdate:
      maxUnavailable: 1
      maxSurge: 1
```

---

### **3.4 Deployment Strategies**

1. **RollingUpdate (Default)**

   * Pods updated **gradually**.
   * Controlled by `maxUnavailable` and `maxSurge`.
   * Ensures **no downtime**.

2. **Recreate**

   * All old pods terminated before new pods are created.
   * May cause downtime.

```yaml
strategy:
  type: Recreate
```

---

### **3.5 Rollback**

* Kubernetes stores **revision history** (default 10 revisions).
* Rollback command:

```bash
kubectl rollout undo deployment/nginx
```

* Rollback to specific revision:

```bash
kubectl rollout undo deployment/nginx --to-revision=2
```

---

### **3.6 Scaling Deployments**

* **Manual Scaling**

```bash
kubectl scale deployment nginx --replicas=5
```

* **Horizontal Pod Autoscaler (HPA)**

```bash
kubectl autoscale deployment nginx --cpu-percent=50 --min=2 --max=10
```

---

### **3.7 Advanced Deployment Concepts**

* **Labels & Selectors:** Ensure proper matching between deployment → ReplicaSet → Pods.
* **Annotations:** Track deployment metadata.
* **Pod Template:** Defines containers, volumes, probes, resource limits.

---

### **4. Pod Health Checks**

* **Liveness Probe:** Restarts container if unhealthy.
* **Readiness Probe:** Marks pod unavailable if not ready.
* Example:

```yaml
livenessProbe:
  httpGet:
    path: /
    port: 80
  initialDelaySeconds: 10
  periodSeconds: 5
readinessProbe:
  httpGet:
    path: /
    port: 80
  initialDelaySeconds: 5
  periodSeconds: 5
```

---

### **5. Best Practices**

* Never use ReplicaSet directly in production; always use Deployments.
* Use labels carefully to manage selectors.
* Set resource requests & limits for pods.
* Implement liveness & readiness probes.
* Use rolling updates to avoid downtime.
* Keep revision history for rollbacks.

---

### **6. Hands-On Lab Summary**

1. Create deployment:

```bash
kubectl create deployment nginx --image=nginx
```

2. Scale it to 3 replicas:

```bash
kubectl scale deployment nginx --replicas=3
```

3. Update deployment (rolling update):

```bash
kubectl set image deployment/nginx nginx=nginx:1.25
kubectl rollout status deployment/nginx
```

4. View rollout history:

```bash
kubectl rollout history deployment nginx
```

5. Rollback:

```bash
kubectl rollout undo deployment nginx
```

6. Apply liveness & readiness probes.
7. Test scaling and auto-scaling.

---


Great — here’s a **deep, no-skips, practical masterclass** for **Day 43–44: Helm & Kustomize**.
I’ll cover **everything** you need to deploy a multi-service app, override values for dev/staging/prod, use advanced templating/overlays, CI/CD patterns, security/best practices, and troubleshooting — with concrete file examples and commands you can copy/paste and run.

# Helm — in depth

Helm = package manager for Kubernetes (charts). Use it to templatize manifest sets, manage releases, lifecycle (install/upgrade/rollback), and share charts.

## 1. Chart anatomy (example multi-service chart for `myapp`)

```
myapp-chart/
├─ Chart.yaml
├─ values.yaml
├─ charts/                # optional subcharts/dependencies
├─ templates/
│  ├─ _helpers.tpl        # template helpers
│  ├─ deployment.yaml
│  ├─ service.yaml
│  ├─ ingress.yaml
│  ├─ configmap.yaml
│  ├─ secret.yaml         # avoid sensitive defaults here
│  ├─ NOTES.txt
│  └─ tests/
│     └─ test-connection.yaml
└─ values.dev.yaml
└─ values.staging.yaml
└─ values.prod.yaml
```

### Chart.yaml (minimal)

```yaml
apiVersion: v2
name: myapp
description: "My multi-service app (frontend+backend+db)"
type: application
version: 0.1.0
appVersion: "1.0.0"
```

### values.yaml (defaults)

```yaml
replicaCount: 2

image:
  repository: myorg/myapp
  tag: "latest"
  pullPolicy: IfNotPresent

frontend:
  enabled: true
  replicaCount: 2
  image:
    repository: myorg/frontend
    tag: "latest"
    pullPolicy: IfNotPresent
  service:
    port: 80

backend:
  enabled: true
  replicaCount: 2
  image:
    repository: myorg/backend
    tag: "latest"

database:
  enabled: true
  postgres:
    image: postgres:15
    persistence:
      enabled: true
      size: 5Gi

resources:
  frontend: {}
  backend: {}
```

### templates/\_helpers.tpl — small helper example

```gotpl
{{- define "myapp.fullname" -}}
{{- printf "%s-%s" .Release.Name .Chart.Name | trunc 63 | trimSuffix "-" -}}
{{- end -}}
```

### templates/deployment.yaml (snippet)

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: {{ include "myapp.fullname" . }}-backend
  labels:
    app: {{ include "myapp.fullname" . }}
spec:
  replicas: {{ .Values.backend.replicaCount }}
  selector:
    matchLabels:
      app: {{ include "myapp.fullname" . }}-backend
  template:
    metadata:
      labels:
        app: {{ include "myapp.fullname" . }}-backend
    spec:
      containers:
      - name: backend
        image: "{{ .Values.backend.image.repository }}:{{ .Values.backend.image.tag }}"
        resources: {{ toYaml .Values.resources.backend | nindent 8 }}
        env:
        - name: DATABASE_HOST
          value: {{ include "myapp.fullname" . }}-db
```

## 2. Install / upgrade / rollback

```bash
# install for dev namespace
helm upgrade --install myapp-dev ./myapp-chart \
  --namespace dev --create-namespace \
  -f ./myapp-chart/values.dev.yaml \
  --values ./myapp-chart/extra-dev.yaml \
  --set image.tag=2023-09-01

# upgrade release
helm upgrade myapp-dev ./myapp-chart -f values.dev.yaml

# list releases
helm list -n dev

# rollback last revision
helm rollback myapp-dev 1

# show manifests rendered for inspection (safe dry-run)
helm template myapp-dev ./myapp-chart -f values.dev.yaml
```

## 3. Environment overrides (dev/staging/prod)

Create dedicated values files per env:

* `values.dev.yaml` → dev-friendly: `replicaCount:1`, image tag `:dev-latest`, no resources or low.
* `values.staging.yaml` → staging: mirror prod but smaller.
* `values.prod.yaml` → production: higher replicas, robust resources, probes, RBAC, ingress TLS.

Use them with `-f` (multiple files applied in order) or `--set` for small overrides:

```bash
helm upgrade --install myapp ./myapp-chart -n prod -f values.prod.yaml --set backend.replicaCount=5
```

## 4. Templating power & common helpers

* `{{ .Values }}`, `{{ .Release }}`.
* Formatting: `toYaml`, `nindent`, `indent`.
* `required "msg" .Values.some.important` fails early if missing.
* `tpl` evaluates strings as templates (useful for dynamic commands).
* `include` / `define` in `_helpers.tpl` for reusable snippets.
* `lookup` (Helm 3) to query cluster objects:

```gotpl
{{- $cm := lookup "v1" "ConfigMap" .Release.Namespace "mycm" -}}
{{- if $cm }} ... {{- end }}
```

## 5. Hooks (migrations, pre/post tasks)

Example pre-install hook for DB migration:

```yaml
apiVersion: batch/v1
kind: Job
metadata:
  name: "{{ include "myapp.fullname" . }}-migrate"
  annotations:
    "helm.sh/hook": pre-install,pre-upgrade
    "helm.sh/hook-weight": "0"
    "helm.sh/hook-delete-policy": hook-succeeded
spec:
  template:
    spec:
      containers:
      - name: migrate
        image: "{{ .Values.backend.image.repository }}:{{ .Values.backend.image.tag }}"
        command: ["sh","-c","/app/migrate"]
      restartPolicy: OnFailure
```

**Notes:** use hooks sparingly; ensure idempotency; set delete policies to clean up.

## 6. Chart dependencies & subcharts

Define dependencies in `Chart.yaml` (v2):

```yaml
dependencies:
  - name: postgres
    version: 10.x.x
    repository: "https://charts.bitnami.com/bitnami"
```

Then:

```bash
helm dependency update ./myapp-chart
```

## 7. Linting, testing, packaging & publishing

```bash
helm lint ./myapp-chart
helm package ./myapp-chart
# create repo index
helm repo index --url https://charts.mycompany.com ./packed-charts
# or push to OCI
helm chart save ./myapp-chart oci://registry.example.com/charts/myapp:0.1.0
helm chart push oci://registry.example.com/charts/myapp:0.1.0
```

Tests:

* `helm test RELEASE` runs Kubernetes Job tests found in `templates/tests/`.

## 8. Values schema (validation)

Add `values.schema.json` in chart to validate `helm install` input — helps avoid mistakes:

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "type": "object",
  "properties": {
    "replicaCount": { "type": "integer" },
    "image": { "type": "object", "properties": { "tag": { "type": "string" } } }
  }
}
```

## 9. Secrets & security

* **Do not** store secrets in `values.yaml` in git.
* Use:

  * External Secret operators (ExternalSecrets, SealedSecrets)
  * Helm secrets (helm-secrets plugin with SOPS) for encrypted values
  * Kubernetes Secrets created separately and referenced in values.
* Use `imagePullSecrets`, RBAC manifest, signed charts where possible.

## 10. Helm best practices summary

* Keep `values.yaml` sane; environment files for overrides.
* Use helpers (`_helpers.tpl`) for names.
* Keep charts small and composable; prefer subcharts or umbrella for multi-app.
* Use CI: `helm lint`, `helm template`, `helm test`.
* Use OCI registries for charts or a private chart repo.
* Parameterize security-sensitive stuff with references to Secrets (not inline).

---

# Kustomize — in depth

Kustomize = overlay-based, declarative customization of raw Kubernetes YAML. Great for environment-specific patches without templating language. Built into `kubectl` (`kubectl apply -k`) and used heavily in GitOps.

## 1. Kustomize structure (recommendation)

```
k8s/
├─ base/
│  ├─ deployment.yaml
│  ├─ service.yaml
│  └─ kustomization.yaml
├─ overlays/
│  ├─ dev/
│  │  ├─ kustomization.yaml
│  │  └─ patch-replicas.yaml
│  ├─ staging/
│  └─ prod/
```

### base/kustomization.yaml

```yaml
resources:
- deployment.yaml
- service.yaml

commonLabels:
  app: myapp
```

### overlays/dev/kustomization.yaml

```yaml
bases:
- ../../base
patchesStrategicMerge:
- patch-replica.yaml

images:
- name: myorg/myapp
  newTag: dev-20250901
```

### overlays/dev/patch-replica.yaml

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: myapp-deployment
spec:
  replicas: 1
```

## 2. Patching options

* `patchesStrategicMerge:` easy for resources that map to fields (like Deployment).
* `patchesJson6902:` for precise JSON path patches.
* `resources:` include raw YAMLs or directories.

## 3. Transformers / common options

* `commonLabels`, `namePrefix`, `nameSuffix`.
* `configMapGenerator` / `secretGenerator`:

```yaml
configMapGenerator:
- name: app-config
  literals:
  - LOG_LEVEL=debug
```

**Warning:** `secretGenerator` generates base64 secrets and writes them to the kustomize output — avoid committing secret generators into public repos. Use SOPS integration or external secret managers.

## 4. Image customization

You can override images per overlay:

```yaml
images:
- name: myorg/backend
  newTag: v1.2.3
```

## 5. Using Kustomize with Helm output

Two patterns:

1. Use helm to render templates then kustomize to apply overlays (CI step: `helm template` → commit/rendered YAML → `kustomize build`).
2. Use the HelmChartInflationGenerator (kustomize plugin) to fetch and expand a Helm chart as resources inside kustomize (less common inside pure kubectl flows).

## 6. Apply / build

```bash
kubectl kustomize overlays/dev | kubectl apply -f -
# or
kubectl apply -k overlays/dev
```

`kustomize build overlays/dev` outputs final manifests.

## 7. Example overlay differences (dev/staging/prod)

* dev: low replicas, image tag `:dev`, `LOG_LEVEL=debug`, no TLS ingress.
* staging: staging replicas, staging image tag, shared test DB.
* prod: higher replicas, resource limits, probes, TLS cert references, stricter security context.

## 8. Kustomize best practices

* Keep `base` immutable; overlays are for environment-specific concerns.
* Use `configMapGenerator` for non-secret configs; keep secrets out of repo.
* Use `components` for reusable patch sets.
* Use `namePrefix` or `commonLabels` for multi-tenant separation.
* Validate `kustomize build` output with `kubectl apply --dry-run=client -f -` and `kubeval`.

---

# Helm vs Kustomize — when to use which (and can they coexist)

* **Helm**: templating, packaging, lifecycle (releases), dependencies. Good for distributed charts you share/publish.
* **Kustomize**: overlay-based, no templating language, ideal for environment patches and GitOps overlays.
  **Patterns:**

1. Use **Helm for packaging apps**, maintain charts upstream. For environments, deploy charts directly with `helm upgrade -f values.env.yaml`.
2. Use **Kustomize for cluster configuration** and overlays — render charts into manifests when you need to further patch them.
3. In GitOps (ArgoCD), you can have apps backed by either Helm charts or Kustomize overlays — both are first class.

---

# Deploy a multi-service app — step-by-step (practical)

### Option A — with Helm (recommended for apps)

1. Build chart (as shown above).
2. For each env maintain `values.{dev,staging,prod}.yaml`.
3. CI job:

   * `helm lint`
   * `helm template` (render and validate)
   * `helm package` and push to OCI/chart repo OR `helm upgrade --install` into cluster (CD).
4. CD:

   * Use `helm upgrade --install` from GitHub Actions / GitLab / ArgoCD (ArgoCD can manage Helm charts directly).

Example GitHub Actions snippet (deploy to cluster):

```yaml
- name: Helm upgrade
  run: |
    helm repo add myrepo https://charts.mycompany.com
    helm upgrade --install myapp-${{ matrix.env }} myrepo/myapp \
      -n ${{ matrix.env }} --create-namespace \
      -f charts/myapp/values.${{ matrix.env }}.yaml
```

### Option B — with Kustomize

1. Keep base + overlays in repo.
2. CI job:

   * `kustomize build overlays/${ENV} | kubectl apply -f -` OR push to ArgoCD (ArgoCD monitors repo and applies overlay).
3. For Helm charts you may render with `helm template` into a `base/` then apply kustomize overlays.

---

# CI/CD & GitOps integrations (practical recipes)

## GitOps (ArgoCD)

* For Helm charts: ArgoCD Application type `Helm`, point to chart repo and values files (per env).
* For Kustomize: ArgoCD Application type `Kustomize`, point to overlay path.

## GitHub Actions pipeline (simple)

* `lint` (helm lint or kustomize build + kubeval)
* `build` (helm package or kustomize build)
* `test` (helm test or apply to ephemeral cluster)
* `deploy` (helm upgrade --install or kubectl apply -k)

## Example: GitHub Actions job (Helm)

```yaml
jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v4
    - uses: azure/setup-helm@v3
    - run: helm lint ./myapp-chart
    - run: helm upgrade --install myapp-dev ./myapp-chart -n dev -f myapp-chart/values.dev.yaml
```

---

# Security & secret handling

* Do **not** commit plaintext secrets. Use:

  * **SealedSecrets** (Bitnami): sealed in git, decrypted in cluster.
  * **ExternalSecrets** or HashiCorp Vault with Kubernetes provider.
  * **Helm + SOPS**: encrypt values.yaml per env (helm-secrets plugin or sops + CI decrypt).
* Use RBAC to limit who can `helm upgrade` in prod.
* Use image signing (cosign) and imagePullPolicy and registries with auth.

---

# Troubleshooting & useful commands

### Helm

```bash
helm list -n dev
helm status myapp-dev -n dev
helm history myapp-dev -n dev
helm rollback myapp-dev <REV>
helm uninstall myapp-dev -n dev
helm get manifest myapp-dev -n dev    # see rendered k8s resources from release
helm template ./myapp-chart -f values.prod.yaml  # preview rendered manifests
helm lint ./myapp-chart
```

### Kustomize / kubectl

```bash
kustomize build overlays/dev | kubectl apply -f -   # or `kubectl apply -k overlays/dev`
kubectl get all -n dev
kubectl diff -k overlays/prod   # needs kubectl diff plugin or use `kubectl kustomize | kubectl diff -f -`
```

### Debugging tips

* If a Helm rendered resource fails: `helm template` to inspect.
* Use `kubectl describe <resource>` and `kubectl logs` for pods.
* For Kustomize overlays not showing changes: ensure patch `metadata.name` matches and proper `patchesStrategicMerge`/json6902 used.
* When combining helm+kustomize, build order: `helm template` → `kustomize build` → `kubectl apply`.

---

# Quick reference: When to pick which approach

* **Publishable packaged app for many consumers** → Helm.
* **Simple environment tweaks without templating** → Kustomize.
* **Large organizations**: Helm charts for apps + Kustomize overlays per cluster/environment managed by GitOps (ArgoCD).


Perfect ğŸ‘ Letâ€™s move to **Day 18â€“19: Stateful Applications in Kubernetes**.
This is where we put **StatefulSets + PVCs + Services** together to run **databases and stateful apps** properly in Kubernetes.

Iâ€™ll go **deep** (concepts â†’ YAML â†’ hands-on â†’ best practices â†’ troubleshooting).

---

# **Day 18â€“19: Stateful Applications (Databases on Kubernetes)**

---

## **1. Why Stateful Applications?**

Most applications (like web apps) are **stateless** â†’ requests can go to any pod.
But databases, message queues, and storage systems are **stateful** â†’ each instance:

* Has a **unique identity**
* Needs **stable storage**
* Requires **stable network identity**

ğŸ‘‰ This is where **StatefulSet** comes in.

---

## **2. StatefulSet vs Deployment**

| Feature      | Deployment     | StatefulSet                           |
| ------------ | -------------- | ------------------------------------- |
| Pod identity | Random         | Stable, ordered (`pod-0`, `pod-1`, â€¦) |
| Storage      | Shared or none | Each pod gets its **own PVC**         |
| Scaling      | Any order      | Ordered (scale-up/down carefully)     |
| Network DNS  | Random pod IPs | Stable DNS (`pod-0.service`)          |
| Use case     | Web apps       | Databases, queues, Zookeeper, Kafka   |

---

## **3. Core Components of Stateful Apps**

1. **Headless Service** (`ClusterIP: None`) â†’ stable DNS names.
   Example: `mysql-0.mysql.default.svc.cluster.local`
2. **StatefulSet** â†’ ensures **ordered creation/deletion** and stable identities.
3. **PersistentVolumeClaims (PVCs)** â†’ ensures each pod gets its own storage.

---

## **4. Headless Service Example**

```yaml
apiVersion: v1
kind: Service
metadata:
  name: mysql
spec:
  clusterIP: None   # Headless Service
  selector:
    app: mysql
  ports:
    - port: 3306
      name: mysql
```

ğŸ‘‰ This ensures each MySQL pod gets a stable DNS entry like:

* `mysql-0.mysql`
* `mysql-1.mysql`

---

## **5. StatefulSet Example (MySQL)**

```yaml
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: mysql
spec:
  serviceName: mysql   # must match headless service
  replicas: 3
  selector:
    matchLabels:
      app: mysql
  template:
    metadata:
      labels:
        app: mysql
    spec:
      containers:
      - name: mysql
        image: mysql:8.0
        ports:
        - containerPort: 3306
        env:
        - name: MYSQL_ROOT_PASSWORD
          value: "rootpass"
        volumeMounts:
        - name: mysql-storage
          mountPath: /var/lib/mysql
  volumeClaimTemplates:
  - metadata:
      name: mysql-storage
    spec:
      accessModes: [ "ReadWriteOnce" ]
      resources:
        requests:
          storage: 1Gi
```

ğŸ‘‰ **Key Points**:

* Each pod gets a **unique PVC** (`mysql-storage-mysql-0`, `mysql-storage-mysql-1`, â€¦).
* Pods are created/deleted **in order**.
* If pod restarts, it **reattaches to the same PVC**.

---

## **6. Verify StatefulSet**

```bash
kubectl get statefulset
kubectl get pods -l app=mysql
kubectl get pvc
kubectl describe pvc mysql-storage-mysql-0
```

ğŸ‘‰ Youâ€™ll see **3 PVCs bound** to 3 pods.

---

## **7. Testing Stateful Behavior**

1. Connect to pod `mysql-0`:

   ```bash
   kubectl exec -it mysql-0 -- mysql -uroot -prootpass
   ```
2. Create a database and insert data.
3. Delete `mysql-0` pod:

   ```bash
   kubectl delete pod mysql-0
   ```
4. Pod will restart â†’ **data still available** (thanks to PVC).

---

## **8. StatefulSet Scaling**

* Scale **up**:

  ```bash
  kubectl scale statefulset mysql --replicas=5
  ```

  â†’ creates `mysql-3`, `mysql-4`.

* Scale **down**:

  ```bash
  kubectl scale statefulset mysql --replicas=2
  ```

  â†’ deletes highest ordinal first (`mysql-2`, then `mysql-1`).

ğŸ‘‰ PVCs remain even after pods are deleted (unless reclaim policy is `Delete`).

---

## **9. Example: Kafka or Redis with StatefulSet**

* Kafka brokers: `kafka-0`, `kafka-1`, `kafka-2`
* Redis cluster: `redis-0`, `redis-1`
* Each needs **stable IDs + storage**.

ğŸ‘‰ Same YAML structure, just change container image and ports.

---

## **10. Best Practices for Stateful Apps**

âœ… Always use **StatefulSet** for DBs, not Deployments.
âœ… Use **Headless Service** for stable DNS.
âœ… Use **StorageClass** for dynamic PVCs.
âœ… Set **PodDisruptionBudgets (PDBs)** to avoid deleting multiple DB pods at once.
âœ… Prefer managed database solutions (RDS, CloudSQL) for production when possible â€” but know StatefulSets for on-prem/cloud-native DBs.

---

## **11. Troubleshooting Stateful Apps**

ğŸ”¹ Pod stuck in **Pending** â†’ Check PVC binding:

```bash
kubectl describe pvc mysql-storage-mysql-0
```

ğŸ”¹ PVC not bound â†’ No PVs available or StorageClass misconfigured.

ğŸ”¹ Pod crashlooping â†’ Check logs:

```bash
kubectl logs mysql-0
```

ğŸ”¹ Scaling down deletes pod but keeps PVC â†’ must manually delete PVC if not needed:

```bash
kubectl delete pvc mysql-storage-mysql-2
```

---

## **12. Key Takeaways**

* **StatefulSet = ordered pods + stable IDs + stable PVCs**
* **Headless Service = stable DNS**
* **PVC + StorageClass = persistent storage**
* Best suited for **databases, queues, and clustered apps**

---


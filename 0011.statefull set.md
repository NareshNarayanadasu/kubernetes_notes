Perfect 👍 Let’s move to **Day 18–19: Stateful Applications in Kubernetes**.
This is where we put **StatefulSets + PVCs + Services** together to run **databases and stateful apps** properly in Kubernetes.

I’ll go **deep** (concepts → YAML → hands-on → best practices → troubleshooting).

---

# **Day 18–19: Stateful Applications (Databases on Kubernetes)**

---

## **1. Why Stateful Applications?**

Most applications (like web apps) are **stateless** → requests can go to any pod.
But databases, message queues, and storage systems are **stateful** → each instance:

* Has a **unique identity**
* Needs **stable storage**
* Requires **stable network identity**

👉 This is where **StatefulSet** comes in.

---

## **2. StatefulSet vs Deployment**

| Feature      | Deployment     | StatefulSet                           |
| ------------ | -------------- | ------------------------------------- |
| Pod identity | Random         | Stable, ordered (`pod-0`, `pod-1`, …) |
| Storage      | Shared or none | Each pod gets its **own PVC**         |
| Scaling      | Any order      | Ordered (scale-up/down carefully)     |
| Network DNS  | Random pod IPs | Stable DNS (`pod-0.service`)          |
| Use case     | Web apps       | Databases, queues, Zookeeper, Kafka   |

---

## **3. Core Components of Stateful Apps**

1. **Headless Service** (`ClusterIP: None`) → stable DNS names.
   Example: `mysql-0.mysql.default.svc.cluster.local`
2. **StatefulSet** → ensures **ordered creation/deletion** and stable identities.
3. **PersistentVolumeClaims (PVCs)** → ensures each pod gets its own storage.

---

## **4. Headless Service Example**

```yaml
apiVersion: v1
kind: Service
metadata:
  name: mysql
spec:
  clusterIP: None   # Headless Service
  selector:
    app: mysql
  ports:
    - port: 3306
      name: mysql
```

👉 This ensures each MySQL pod gets a stable DNS entry like:

* `mysql-0.mysql`
* `mysql-1.mysql`

---

## **5. StatefulSet Example (MySQL)**

```yaml
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: mysql
spec:
  serviceName: mysql   # must match headless service
  replicas: 3
  selector:
    matchLabels:
      app: mysql
  template:
    metadata:
      labels:
        app: mysql
    spec:
      containers:
      - name: mysql
        image: mysql:8.0
        ports:
        - containerPort: 3306
        env:
        - name: MYSQL_ROOT_PASSWORD
          value: "rootpass"
        volumeMounts:
        - name: mysql-storage
          mountPath: /var/lib/mysql
  volumeClaimTemplates:
  - metadata:
      name: mysql-storage
    spec:
      accessModes: [ "ReadWriteOnce" ]
      resources:
        requests:
          storage: 1Gi
```

👉 **Key Points**:

* Each pod gets a **unique PVC** (`mysql-storage-mysql-0`, `mysql-storage-mysql-1`, …).
* Pods are created/deleted **in order**.
* If pod restarts, it **reattaches to the same PVC**.

---

## **6. Verify StatefulSet**

```bash
kubectl get statefulset
kubectl get pods -l app=mysql
kubectl get pvc
kubectl describe pvc mysql-storage-mysql-0
```

👉 You’ll see **3 PVCs bound** to 3 pods.

---

## **7. Testing Stateful Behavior**

1. Connect to pod `mysql-0`:

   ```bash
   kubectl exec -it mysql-0 -- mysql -uroot -prootpass
   ```
2. Create a database and insert data.
3. Delete `mysql-0` pod:

   ```bash
   kubectl delete pod mysql-0
   ```
4. Pod will restart → **data still available** (thanks to PVC).

---

## **8. StatefulSet Scaling**

* Scale **up**:

  ```bash
  kubectl scale statefulset mysql --replicas=5
  ```

  → creates `mysql-3`, `mysql-4`.

* Scale **down**:

  ```bash
  kubectl scale statefulset mysql --replicas=2
  ```

  → deletes highest ordinal first (`mysql-2`, then `mysql-1`).

👉 PVCs remain even after pods are deleted (unless reclaim policy is `Delete`).

---

## **9. Example: Kafka or Redis with StatefulSet**

* Kafka brokers: `kafka-0`, `kafka-1`, `kafka-2`
* Redis cluster: `redis-0`, `redis-1`
* Each needs **stable IDs + storage**.

👉 Same YAML structure, just change container image and ports.

---

## **10. Best Practices for Stateful Apps**

✅ Always use **StatefulSet** for DBs, not Deployments.
✅ Use **Headless Service** for stable DNS.
✅ Use **StorageClass** for dynamic PVCs.
✅ Set **PodDisruptionBudgets (PDBs)** to avoid deleting multiple DB pods at once.
✅ Prefer managed database solutions (RDS, CloudSQL) for production when possible — but know StatefulSets for on-prem/cloud-native DBs.

---

## **11. Troubleshooting Stateful Apps**

🔹 Pod stuck in **Pending** → Check PVC binding:

```bash
kubectl describe pvc mysql-storage-mysql-0
```

🔹 PVC not bound → No PVs available or StorageClass misconfigured.

🔹 Pod crashlooping → Check logs:

```bash
kubectl logs mysql-0
```

🔹 Scaling down deletes pod but keeps PVC → must manually delete PVC if not needed:

```bash
kubectl delete pvc mysql-storage-mysql-2
```

---

## **12. Key Takeaways**

* **StatefulSet = ordered pods + stable IDs + stable PVCs**
* **Headless Service = stable DNS**
* **PVC + StorageClass = persistent storage**
* Best suited for **databases, queues, and clustered apps**

---


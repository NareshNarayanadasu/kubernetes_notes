Here’s a **detailed, text-only guide for Day 63: Multi-Cluster Lab**, fully covering all concepts and hands-on steps.

---

# **Day 63: Multi-Cluster Kubernetes Lab**

---

## **1. Lab Objective**

* Deploy workloads across **multiple Kubernetes clusters**.
* Enable **cross-cluster communication and service discovery**.
* Understand challenges in **multi-cluster management**, networking, and DNS.

---

## **2. Why Multi-Cluster?**

* High availability: workloads run in different clusters to avoid single points of failure.
* Disaster recovery: one cluster fails, another can serve traffic.
* Geographic distribution: reduce latency by running clusters in different regions.
* Workload separation: dev/staging/prod isolation.

---

## **3. Multi-Cluster Approaches**

| Approach                         | Description                                                                |
| -------------------------------- | -------------------------------------------------------------------------- |
| **Manual**                       | Connect clusters via VPN or service mesh.                                  |
| **Service Mesh**                 | Use Istio/Linkerd for cross-cluster service discovery and traffic routing. |
| **Cluster Federation (KubeFed)** | Federate resources to multiple clusters.                                   |
| **DNS & Load Balancing**         | Use external DNS or load balancers for cross-cluster access.               |

---

## **4. Lab Prerequisites**

* Two **kind clusters** (cluster1, cluster2).
* `kubectl` contexts configured for both clusters:

```bash
kubectl config get-contexts
```

---

## **5. Hands-On Steps**

### **5.1 Create two Kind Clusters**

```bash
kind create cluster --name cluster1
kind create cluster --name cluster2
kubectl cluster-info --context kind-cluster1
kubectl cluster-info --context kind-cluster2
```

### **5.2 Deploy Sample App in Cluster1**

```bash
kubectl create ns multi-cluster
kubectl apply -f - <<EOF
apiVersion: apps/v1
kind: Deployment
metadata:
  name: nginx
  namespace: multi-cluster
spec:
  replicas: 2
  selector:
    matchLabels:
      app: nginx
  template:
    metadata:
      labels:
        app: nginx
    spec:
      containers:
      - name: nginx
        image: nginx:latest
        ports:
        - containerPort: 80
EOF

kubectl expose deployment nginx --type=ClusterIP --name=nginx-svc -n multi-cluster
kubectl get svc -n multi-cluster
```

### **5.3 Deploy Sample App in Cluster2**

* Repeat above steps, but name the deployment differently (`nginx-cluster2`).

---

## **6. Enable Cross-Cluster Service Discovery**

### **6.1 Option 1: Using External DNS**

* Assign each cluster a unique external IP or LoadBalancer.
* Update DNS entries to allow cluster1 pods to resolve cluster2 services.

### **6.2 Option 2: Using Service Mesh (Istio example)**

1. Install Istio in both clusters:

```bash
istioctl install --set profile=demo -y
```

2. Enable **remote cluster discovery**:

```bash
istioctl x create-remote-secret --name cluster2 | kubectl apply -f - --context kind-cluster1
istioctl x create-remote-secret --name cluster1 | kubectl apply -f - --context kind-cluster2
```

3. Verify **service discovery**:

```bash
kubectl get svc -n multi-cluster --context kind-cluster1
kubectl get svc -n multi-cluster --context kind-cluster2
```

### **6.3 Test Cross-Cluster Communication**

* From cluster1 pod:

```bash
kubectl exec -it <nginx-pod> -n multi-cluster -- curl http://nginx-svc.multi-cluster.svc.cluster2.local
```

* Should reach the nginx service in cluster2.

---

## **7. Key Concepts**

| Concept           | Description                                                                             |
| ----------------- | --------------------------------------------------------------------------------------- |
| Cluster Contexts  | Manage multiple clusters via `kubectl config`                                           |
| Cross-Cluster DNS | Services in one cluster can resolve names in another cluster (requires mesh/federation) |
| Federation        | KubeFed allows automatic replication of resources across clusters                       |
| Service Mesh      | Handles routing, discovery, and traffic between clusters                                |

---

## **8. Best Practices**

1. Keep clusters **independent**, avoid tightly coupled workloads.
2. Use **service mesh** for production-grade multi-cluster communication.
3. Monitor clusters centrally with **Prometheus/Grafana**.
4. Secure inter-cluster traffic with **mTLS**.
5. Automate context switching and deployment using **CI/CD pipelines**.

---

## **9. Troubleshooting**

| Issue                                                | Solution                                                                |
| ---------------------------------------------------- | ----------------------------------------------------------------------- |
| Pods in one cluster cannot reach services in another | Check service DNS, network policies, or mesh configuration              |
| Cluster context wrong                                | Verify `kubectl config get-contexts` and use correct `--context`        |
| Mesh traffic blocked                                 | Check Istio gateways, virtual services, and remote secret configuration |

---

## **10. Lab Summary**

* Deployed workloads in **two separate clusters**.
* Enabled **cross-cluster service discovery** using external DNS or Istio.
* Learned how to manage **multi-cluster Kubernetes** environments.
* Understood **networking, DNS, and service mesh concepts** for multi-cluster deployments.

✅ **Outcome:**

* Hands-on experience with multi-cluster deployments.
* Knowledge to design **HA, DR, and geographically distributed applications**.

---



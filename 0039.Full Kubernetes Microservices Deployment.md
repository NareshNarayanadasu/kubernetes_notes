Here’s a **detailed, text-only guide for Day 70: Final Project – Full Microservices Application Deployment**, covering every aspect for in-depth study and hands-on practice.

---

# **Day 70: Final Project – Full Kubernetes Microservices Deployment**

---

## **1. Lab Objective**

* Deploy a **production-grade microservices application** on Kubernetes.

* Apply **advanced concepts** learned over the course:

  * **Canary deployments** and **rollbacks**
  * **Monitoring, logging, and alerts**
  * **Security** with NetworkPolicies and RBAC
  * **Backup & restore**

* Test **observability, resiliency, and security** end-to-end.

---

## **2. Application Components**

| Component    | Description                                  |
| ------------ | -------------------------------------------- |
| Frontend     | Web UI (e.g., Nginx, React app)              |
| Backend      | REST API (e.g., Node.js, Python Flask)       |
| Database     | PostgreSQL or MySQL StatefulSet              |
| Service Mesh | Optional for traffic routing (Istio/Linkerd) |
| Monitoring   | Prometheus + Grafana                         |
| Logging      | Loki/EFK stack                               |
| Alerts       | Alertmanager via Slack/Email                 |
| Security     | RBAC, PodSecurityPolicies, NetworkPolicies   |
| Backup       | Velero or native PV snapshot                 |

---

## **3. Step 1: Namespace & RBAC Setup**

```bash
kubectl create ns final-project
kubectl create role dev-role --verb=get,list,create,update --resource=pods,deployments,services -n final-project
kubectl create rolebinding dev-binding --role=dev-role --user=developer -n final-project
```

* Isolates project workloads and enforces **least privilege**.

---

## **4. Step 2: Deploy Database with StatefulSet**

```yaml
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: db
  namespace: final-project
spec:
  serviceName: db-svc
  replicas: 3
  selector:
    matchLabels:
      app: db
  template:
    metadata:
      labels:
        app: db
    spec:
      containers:
      - name: postgres
        image: postgres:14
        ports:
        - containerPort: 5432
        env:
        - name: POSTGRES_PASSWORD
          value: "mypassword"
        volumeMounts:
        - name: pgdata
          mountPath: /var/lib/postgresql/data
  volumeClaimTemplates:
  - metadata:
      name: pgdata
    spec:
      accessModes: ["ReadWriteOnce"]
      resources:
        requests:
          storage: 1Gi
```

* Apply Headless Service for stable pod identities.
* Enables **HA database setup**.

---

## **5. Step 3: Deploy Backend Service**

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: backend
  namespace: final-project
spec:
  replicas: 3
  selector:
    matchLabels:
      app: backend
  template:
    metadata:
      labels:
        app: backend
    spec:
      containers:
      - name: backend
        image: my-backend:latest
        ports:
        - containerPort: 5000
        env:
        - name: DATABASE_HOST
          value: db-svc.final-project.svc.cluster.local
```

* Expose via **ClusterIP or NodePort service**.

---

## **6. Step 4: Deploy Frontend Service**

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: frontend
  namespace: final-project
spec:
  replicas: 2
  selector:
    matchLabels:
      app: frontend
  template:
    metadata:
      labels:
        app: frontend
    spec:
      containers:
      - name: frontend
        image: my-frontend:latest
        ports:
        - containerPort: 80
```

* Expose with **LoadBalancer or Ingress** for external access.

---

## **7. Step 5: Canary Deployment & Rollback**

1. Deploy **new version** of backend:

```bash
kubectl set image deployment/backend backend=my-backend:v2 -n final-project
```

2. Monitor **rollout status**:

```bash
kubectl rollout status deployment/backend -n final-project
```

3. If issue detected → **rollback**:

```bash
kubectl rollout undo deployment/backend -n final-project
```

* Canary allows **partial traffic test** before full rollout.

---

## **8. Step 6: Monitoring, Logging & Alerts**

### **8.1 Metrics**

* Prometheus monitors pod CPU, memory, and request metrics.
* Grafana dashboards visualize **frontend/backend performance**.

### **8.2 Logs**

* Loki/EFK stack centralizes logs from all pods.
* Useful for **debugging errors and request tracing**.

### **8.3 Alerts**

* Alertmanager triggers **Slack/Email alerts** for:

  * Pod crashes
  * CPU/memory thresholds
  * Deployment failures

```yaml
apiVersion: monitoring.coreos.com/v1
kind: AlertmanagerConfig
metadata:
  name: alert-config
  namespace: final-project
```

---

## **9. Step 7: Security Enforcement**

### **9.1 Network Policies**

```yaml
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: allow-backend
  namespace: final-project
spec:
  podSelector:
    matchLabels:
      app: backend
  ingress:
    - from:
        - podSelector:
            matchLabels:
              app: frontend
```

* Only frontend pods can access backend pods.

### **9.2 Pod Security & RBAC**

* Enforce **restricted pod security**.
* Ensure **least privilege RBAC roles** applied.

---

## **10. Step 8: Backup & Restore**

* Install **Velero**:

```bash
velero install --provider aws --bucket my-bucket --secret-file ./credentials-velero
```

* Backup the namespace:

```bash
velero backup create final-project-backup --include-namespaces final-project
```

* Simulate disaster (delete deployment):

```bash
kubectl delete ns final-project
```

* Restore:

```bash
velero restore create --from-backup final-project-backup
kubectl get all -n final-project
```

* Verifies **resiliency and DR readiness**.

---

## **11. Step 9: Observability Validation**

* Check metrics in **Grafana**:

  * Backend response times, frontend traffic, DB queries.
* Check logs in **Loki/Kibana** for errors.
* Ensure **alerts** fire correctly when thresholds exceeded.

---

## **12. Step 10: Lab Validation**

* Access frontend app externally.
* Test API connectivity to backend and DB.
* Perform **canary deployment** → simulate failure → rollback.
* Validate **network policies** restrict unauthorized access.
* Test backup/restore workflow.

---

## **13. Best Practices Applied**

* **Namespaces & RBAC** for workload isolation
* **StatefulSet** for HA database
* **Deployment & canary rollout** for backend
* **PodSecurity & NetworkPolicies** for security
* **Prometheus/Grafana/Loki** for monitoring and logging
* **Velero** for backup & disaster recovery

---

## **14. Lab Summary**

* Successfully deployed a **full microservices application** with HA, security, observability, and backup.
* Practiced **canary deployment, rollback, monitoring, logging, network policies, RBAC, and backup/restore**.
* Simulated **real production scenarios** and validated **resilience and security**.

✅ **Outcome:**

* End-to-end understanding of **production-grade Kubernetes applications**.
* Ability to implement **secure, observable, and resilient workloads**.
* Ready for **real-world enterprise Kubernetes deployments**.



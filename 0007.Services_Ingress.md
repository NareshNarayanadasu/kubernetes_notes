Great â€” letâ€™s go **very deep into Day 10â€“11: Services & Ingress**.
This is where Kubernetes networking and application exposure really **come together**. Iâ€™ll cover **Services (ClusterIP, NodePort, LoadBalancer)** again but with **production-grade depth**, and then dive into **Ingress controllers, rules, TLS, and testing**.

---

# **Day 10â€“11: Services & Ingress â€“ Complete In-Depth Guide**

---

## **1. Services Recap â€“ Why Services Are Needed**

* Pods are **ephemeral** â€“ they die and restart with **new IPs**.
* Services provide a **stable, virtual IP (ClusterIP)** that maps to a group of pods.
* Uses **label selectors** to match pods.
* Implements **load balancing** (round-robin).

---

### **1.1 ClusterIP**

* Default service type.
* Only accessible **inside cluster**.
* Internal communication between microservices.

**YAML Example â€“ ClusterIP**

```yaml
apiVersion: v1
kind: Service
metadata:
  name: nginx-clusterip
spec:
  selector:
    app: nginx
  ports:
  - port: 80
    targetPort: 80
  type: ClusterIP
```

**Commands**

```bash
kubectl apply -f nginx-clusterip.yaml
kubectl get svc nginx-clusterip
kubectl exec -it <pod> -- curl nginx-clusterip:80
```

---

### **1.2 NodePort**

* Exposes service on a **port (30000â€“32767)** on each node.
* Access via:
  `http://<node-IP>:<NodePort>`
* Good for **testing**, not recommended for production.

**YAML Example â€“ NodePort**

```yaml
apiVersion: v1
kind: Service
metadata:
  name: nginx-nodeport
spec:
  selector:
    app: nginx
  ports:
  - port: 80
    targetPort: 80
    nodePort: 31000
  type: NodePort
```

**Test**

```bash
kubectl apply -f nginx-nodeport.yaml
curl http://<node-IP>:31000
```

---

### **1.3 LoadBalancer**

* Exposes service externally via a **cloud providerâ€™s LB** (AWS ELB, GCP LB, Azure LB).
* Works only in **cloud environments** or with **MetalLB** in bare-metal clusters.
* Internally, it creates **NodePort + external LB**.

**YAML Example â€“ LoadBalancer**

```yaml
apiVersion: v1
kind: Service
metadata:
  name: nginx-lb
spec:
  selector:
    app: nginx
  ports:
  - port: 80
    targetPort: 80
  type: LoadBalancer
```

**Test**

```bash
kubectl apply -f nginx-lb.yaml
kubectl get svc nginx-lb
# Use EXTERNAL-IP
curl http://<external-ip>
```

---

## **2. Ingress â€“ Smarter Traffic Routing**

### **2.1 What is Ingress?**

* **Ingress = HTTP reverse proxy + routing rules**.
* Exposes multiple services via a **single entry point** (usually port 80/443).
* Supports:

  * Host-based routing (e.g., `api.example.com`, `shop.example.com`)
  * Path-based routing (`/api â†’ service1`, `/app â†’ service2`)
  * SSL/TLS termination

ðŸ‘‰ Ingress **needs an Ingress Controller** (Nginx, Traefik, HAProxy, Istio, etc.).

---

### **2.2 Ingress Controller**

* Kubernetes does **not provide an Ingress controller by default**.
* Most common:

  * **NGINX Ingress Controller**
  * Traefik
  * HAProxy
  * Istio Gateway (service mesh)

ðŸ‘‰ In this curriculum, weâ€™ll use **NGINX Ingress**.

---

### **2.3 Install NGINX Ingress Controller**

For clusters with Helm:

```bash
helm repo add ingress-nginx https://kubernetes.github.io/ingress-nginx
helm repo update
helm install nginx-ingress ingress-nginx/ingress-nginx
```

For YAML manifests:

```bash
kubectl apply -f https://raw.githubusercontent.com/kubernetes/ingress-nginx/main/deploy/static/provider/cloud/deploy.yaml
```

Verify:

```bash
kubectl get pods -n ingress-nginx
kubectl get svc -n ingress-nginx
```

---

### **2.4 Ingress Resource Example**

Deploy two apps for routing:

**App 1 (hello):**

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: hello
spec:
  replicas: 2
  selector:
    matchLabels:
      app: hello
  template:
    metadata:
      labels:
        app: hello
    spec:
      containers:
      - name: hello
        image: nginxdemos/hello
        ports:
        - containerPort: 80
---
apiVersion: v1
kind: Service
metadata:
  name: hello-svc
spec:
  selector:
    app: hello
  ports:
  - port: 80
    targetPort: 80
  type: ClusterIP
```

**App 2 (nginx):**

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: nginx
spec:
  replicas: 2
  selector:
    matchLabels:
      app: nginx
  template:
    metadata:
      labels:
        app: nginx
    spec:
      containers:
      - name: nginx
        image: nginx
        ports:
        - containerPort: 80
---
apiVersion: v1
kind: Service
metadata:
  name: nginx-svc
spec:
  selector:
    app: nginx
  ports:
  - port: 80
    targetPort: 80
  type: ClusterIP
```

---

**Ingress Resource â€“ Path Based Routing**

```yaml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: demo-ingress
spec:
  ingressClassName: nginx
  rules:
  - host: demo.local
    http:
      paths:
      - path: /hello
        pathType: Prefix
        backend:
          service:
            name: hello-svc
            port:
              number: 80
      - path: /nginx
        pathType: Prefix
        backend:
          service:
            name: nginx-svc
            port:
              number: 80
```

---

### **2.5 Testing Ingress**

1. Get Ingress Controller service:

```bash
kubectl get svc -n ingress-nginx
```

2. Add host entry (local cluster):

```bash
# Map to Node IP / Minikube IP
sudo echo "<INGRESS-IP> demo.local" >> /etc/hosts
```

3. Test with curl:

```bash
curl http://demo.local/hello
curl http://demo.local/nginx
```

---

### **2.6 Ingress with TLS**

Add TLS certs (self-signed for testing):

```bash
kubectl create secret tls demo-tls --key tls.key --cert tls.crt
```

Update Ingress:

```yaml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: demo-ingress
spec:
  ingressClassName: nginx
  tls:
  - hosts:
    - demo.local
    secretName: demo-tls
  rules:
  - host: demo.local
    http:
      paths:
      - path: /hello
        pathType: Prefix
        backend:
          service:
            name: hello-svc
            port:
              number: 80
```

Test HTTPS:

```bash
curl -k https://demo.local/hello
```

---

## **3. Hands-On Summary**

âœ… **ClusterIP** â€“ internal only
âœ… **NodePort** â€“ external via NodeIP\:port
âœ… **LoadBalancer** â€“ cloud external IP
âœ… **Ingress** â€“ central entry point with smart routing

---

## **4. Best Practices**

* Use **ClusterIP** for service-to-service communication inside cluster.
* Use **Ingress** instead of multiple NodePorts.
* Always configure **TLS termination** at Ingress.
* Use **Helm or YAML manifests** for Ingress controllers.
* Apply **NetworkPolicies** to secure service communication.

---

## **5. Key Takeaways**

* **Services** = stable endpoints for pods.
* **Ingress** = advanced HTTP routing, TLS termination, single entry point.
* **NGINX Ingress Controller** is most widely used in production.
* With Ingress, you can host **multiple apps behind one IP/domain**.

---



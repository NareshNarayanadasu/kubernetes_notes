Absolutely! Let’s dive deep into **Day 45–46: GitOps with ArgoCD/Flux**, covering **concepts → architecture → installation → hands-on labs → application sync → environment management → best practices → troubleshooting**. I’ll leave no topic skipped and make it fully understandable for someone with 5+ years experience.

---

# **Day 45–46: GitOps (ArgoCD / Flux)**

---

## **1. What is GitOps?**

GitOps is a **declarative approach to Kubernetes CI/CD** where:

1. **Git is the single source of truth**:

   * All cluster configurations, application manifests, Helm charts, and environment overlays live in Git.
2. **Automated synchronization**:

   * Git changes automatically sync with the cluster.
3. **Observability & rollback**:

   * Changes are versioned.
   * Rollbacks are easy by reverting Git commits.

**Benefits:**

* Version-controlled infrastructure.
* Self-healing clusters (auto-correct drift).
* Audit trail of every change.
* Declarative, reproducible environments.
* Safe CI/CD workflows with approvals via Git.

---

## **2. GitOps Tools Overview**

| Tool        | Type       | Key Features                                                                                           |
| ----------- | ---------- | ------------------------------------------------------------------------------------------------------ |
| **ArgoCD**  | Controller | Watches Git repos → syncs to cluster, supports Helm, Kustomize, plain YAML, directories, multi-cluster |
| **Flux v2** | Controller | GitOps operator, automated reconciliation, supports HelmRelease CRDs, image updates                    |

We’ll focus mainly on **ArgoCD** because it’s widely used, but concepts transfer to Flux.

---

## **3. ArgoCD Architecture**

* **Repo Server**: Reads Git repo, calculates desired state.
* **Application Controller**: Reconciles cluster to desired state.
* **API Server & UI**: Manage applications, view sync status.
* **Redis**: For caching state.
* **Dex / SSO (optional)**: User authentication.

**Workflow:**

```
Git Repo → ArgoCD → Cluster (desired state applied via kubectl)
```

---

## **4. Installation of ArgoCD**

### Step 1: Install ArgoCD in `argocd` namespace

```bash
kubectl create namespace argocd
kubectl apply -n argocd -f https://raw.githubusercontent.com/argoproj/argo-cd/stable/manifests/install.yaml
```

### Step 2: Expose ArgoCD API/UI

**Option 1: Port-forward (local access)**

```bash
kubectl port-forward svc/argocd-server -n argocd 8080:443
```

Open [https://localhost:8080](https://localhost:8080)

**Option 2: Ingress (for multi-user access)**

```yaml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: argocd-server-ingress
  namespace: argocd
  annotations:
    kubernetes.io/ingress.class: nginx
spec:
  rules:
  - host: argocd.mycompany.com
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: argocd-server
            port:
              number: 443
```

### Step 3: Login

```bash
# get default admin password
kubectl -n argocd get secret argocd-initial-admin-secret -o jsonpath="{.data.password}" | base64 -d
```

---

## **5. First Application Sync**

### Step 1: Git Repo Structure

Example multi-service repo (Helm + Kustomize mix):

```
gitops-repo/
├─ apps/
│  ├─ frontend/
│  │  ├─ base/
│  │  └─ overlays/dev
│  ├─ backend/
│  └─ db/
├─ clusters/
│  ├─ dev/
│  │  └─ kustomization.yaml
│  └─ prod/
│     └─ kustomization.yaml
```

### Step 2: Create ArgoCD Application

```bash
argocd app create myapp-dev \
  --repo https://github.com/myorg/gitops-repo.git \
  --path clusters/dev \
  --dest-server https://kubernetes.default.svc \
  --dest-namespace dev \
  --sync-policy automated
```

### Step 3: Sync Application

```bash
# via CLI
argocd app sync myapp-dev

# check status
argocd app get myapp-dev
```

* UI shows desired vs live state.
* Any drift (manual change in cluster) → auto-reconciled if `automated` sync enabled.

---

## **6. Automated Sync & Drift Detection**

* **Manual sync**: Ops team approves changes.
* **Automated sync**: ArgoCD applies changes automatically.
* Drift detection:

```bash
kubectl apply -f some-manual-change.yaml
argocd app diff myapp-dev
```

ArgoCD shows **differences between Git and live cluster**.

---

## **7. Multi-Environment Deployment**

* **Dev**: Automated sync, lower replicas, debug logging.
* **Staging**: Automated or manual sync, mirror prod.
* **Prod**: Manual approval required, higher replicas, probes, resource limits.

### Example: Kustomize overlays per env

```
clusters/
├─ dev/
│  └─ kustomization.yaml
├─ staging/
│  └─ kustomization.yaml
└─ prod/
   └─ kustomization.yaml
```

* ArgoCD creates separate applications per environment:

```bash
argocd app create backend-prod \
  --repo https://github.com/myorg/gitops-repo.git \
  --path clusters/prod/backend \
  --dest-namespace prod \
  --sync-policy automated
```

---

## **8. Helm + ArgoCD**

* ArgoCD can directly deploy Helm charts:

```bash
argocd app create frontend-dev \
  --repo https://github.com/myorg/gitops-repo.git \
  --path apps/frontend \
  --dest-namespace dev \
  --dest-server https://kubernetes.default.svc \
  --helm-set image.tag=dev-20250901 \
  --sync-policy automated
```

* Helm values can be overridden via:

  * `--helm-set`
  * `values.yaml` in Git repo
  * Separate env-specific values files

---

## **9. Rollbacks**

* Rollback to previous revision (GitOps style = revert Git commit):

```bash
git revert <commit-hash>
git push origin main
```

ArgoCD detects change → syncs cluster automatically.

* CLI alternative:

```bash
argocd app rollback myapp-dev 1
```

---

## **10. RBAC & Multi-team setups**

* ArgoCD supports **role-based access control**:

  * Developers: dev namespace only
  * QA: staging only
  * SRE: prod + cluster-wide
* RBAC policies in `argocd-rbac-cm` ConfigMap:

```yaml
policy.csv: |
  p, role:developer, applications, get, myapp-dev/*, allow
  p, role:sre, applications, *, *, allow
```

---

## **11. Notifications & Alerts**

* Integrates with **Slack, Teams, Email, Webhooks**:

```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: argocd-notifications-cm
  namespace: argocd
data:
  service.slack: |
    token: $SLACK_TOKEN
  subscriptions: |
    - recipients:
        - slack:devops-alerts
      triggers:
        - on-sync-failed
```

* Alert when sync fails or rollback needed.

---

## **12. Flux v2 (alternative GitOps)**

* Flux monitors Git repo continuously → applies manifests automatically.
* Supports:

  * HelmRelease CRDs → manage Helm charts
  * Image update automation → automatically bump image tags
* CLI:

```bash
flux bootstrap github \
  --owner=myorg --repository=gitops-repo \
  --branch=main --path=clusters/dev
```

---

## **13. Best Practices**

✅ Keep **Git repo as single source of truth**.
✅ Avoid manual changes in cluster → let GitOps enforce.
✅ Separate **environments with folders/overlays**.
✅ Use **branch protection / PR reviews** → approvals before prod deployment.
✅ Monitor ArgoCD application status → alerts on drift/failure.
✅ Store secrets in **SealedSecrets / ExternalSecrets** → not plaintext Git.
✅ Use **automated testing**: dry-run manifests in CI before merging.

---

## **14. Troubleshooting**

* **Application OutOfSync** → check manifests in Git vs cluster.
* **Sync fails** → inspect `kubectl describe` on failed resources, RBAC issues, missing CRDs.
* **Manual changes lost?** → intended GitOps behavior: cluster matches Git.
* **Access denied** → check ArgoCD RBAC & service account permissions.
* **Helm chart values not applied** → check `values.yaml` path, `--helm-set` overrides.

---

## **15. Hands-On Lab**

1. Install ArgoCD in cluster.
2. Create a Git repo with dev/staging/prod overlays (Kustomize or Helm).
3. Create ArgoCD applications per environment.
4. Make changes in dev branch → PR → merge → observe ArgoCD auto-sync (or manual sync).
5. Revert PR


→ cluster auto-rolls back.
6\. Simulate drift: manually edit a resource → ArgoCD detects and optionally auto-corrects.

---

